// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"github.com/flexprice/go-sdk-temp/v2/internal/utils"
)

type InvoiceStatus string

const (
	InvoiceStatusDraft     InvoiceStatus = "DRAFT"
	InvoiceStatusFinalized InvoiceStatus = "FINALIZED"
	InvoiceStatusVoided    InvoiceStatus = "VOIDED"
)

func (e InvoiceStatus) ToPointer() *InvoiceStatus {
	return &e
}
func (e *InvoiceStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DRAFT":
		fallthrough
	case "FINALIZED":
		fallthrough
	case "VOIDED":
		*e = InvoiceStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InvoiceStatus: %v", v)
	}
}

// InvoiceType - invoice_type filters by the nature of the invoice (SUBSCRIPTION, ONE_OFF, or CREDIT)
// Use this to separate recurring charges from one-time fees or credit adjustments
type InvoiceType string

const (
	InvoiceTypeSubscription InvoiceType = "SUBSCRIPTION"
	InvoiceTypeOneOff       InvoiceType = "ONE_OFF"
	InvoiceTypeCredit       InvoiceType = "CREDIT"
)

func (e InvoiceType) ToPointer() *InvoiceType {
	return &e
}
func (e *InvoiceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SUBSCRIPTION":
		fallthrough
	case "ONE_OFF":
		fallthrough
	case "CREDIT":
		*e = InvoiceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InvoiceType: %v", v)
	}
}

type GetInvoicesOrder string

const (
	GetInvoicesOrderAsc  GetInvoicesOrder = "asc"
	GetInvoicesOrderDesc GetInvoicesOrder = "desc"
)

func (e GetInvoicesOrder) ToPointer() *GetInvoicesOrder {
	return &e
}
func (e *GetInvoicesOrder) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "asc":
		fallthrough
	case "desc":
		*e = GetInvoicesOrder(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetInvoicesOrder: %v", v)
	}
}

type PaymentStatus string

const (
	PaymentStatusInitiated         PaymentStatus = "INITIATED"
	PaymentStatusPending           PaymentStatus = "PENDING"
	PaymentStatusProcessing        PaymentStatus = "PROCESSING"
	PaymentStatusSucceeded         PaymentStatus = "SUCCEEDED"
	PaymentStatusOverpaid          PaymentStatus = "OVERPAID"
	PaymentStatusFailed            PaymentStatus = "FAILED"
	PaymentStatusRefunded          PaymentStatus = "REFUNDED"
	PaymentStatusPartiallyRefunded PaymentStatus = "PARTIALLY_REFUNDED"
)

func (e PaymentStatus) ToPointer() *PaymentStatus {
	return &e
}
func (e *PaymentStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INITIATED":
		fallthrough
	case "PENDING":
		fallthrough
	case "PROCESSING":
		fallthrough
	case "SUCCEEDED":
		fallthrough
	case "OVERPAID":
		fallthrough
	case "FAILED":
		fallthrough
	case "REFUNDED":
		fallthrough
	case "PARTIALLY_REFUNDED":
		*e = PaymentStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PaymentStatus: %v", v)
	}
}

type GetInvoicesStatus string

const (
	GetInvoicesStatusPublished GetInvoicesStatus = "published"
	GetInvoicesStatusDeleted   GetInvoicesStatus = "deleted"
	GetInvoicesStatusArchived  GetInvoicesStatus = "archived"
)

func (e GetInvoicesStatus) ToPointer() *GetInvoicesStatus {
	return &e
}
func (e *GetInvoicesStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "published":
		fallthrough
	case "deleted":
		fallthrough
	case "archived":
		*e = GetInvoicesStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetInvoicesStatus: %v", v)
	}
}

type GetInvoicesRequest struct {
	// amount_due_gt filters invoices with a total amount due greater than the specified value
	// Useful for finding invoices above a certain threshold or identifying high-value invoices
	AmountDueGt *float64 `queryParam:"style=form,explode=true,name=amount_due_gt"`
	// amount_remaining_gt filters invoices with an outstanding balance greater than the specified value
	// Useful for finding invoices that still have significant unpaid amounts
	AmountRemainingGt *float64 `queryParam:"style=form,explode=true,name=amount_remaining_gt"`
	// customer_id filters invoices for a specific customer using FlexPrice's internal customer ID
	// This is the ID returned by FlexPrice when creating or retrieving customers
	CustomerID *string `queryParam:"style=form,explode=true,name=customer_id"`
	EndTime    *string `queryParam:"style=form,explode=true,name=end_time"`
	Expand     *string `queryParam:"style=form,explode=true,name=expand"`
	// external_customer_id filters invoices for a customer using your system's customer identifier
	// This is the ID you provided when creating the customer in FlexPrice
	ExternalCustomerID *string `queryParam:"style=form,explode=true,name=external_customer_id"`
	// invoice_ids restricts results to invoices with the specified IDs
	// Use this to retrieve specific invoices when you know their exact identifiers
	InvoiceIds []string `queryParam:"style=form,explode=false,name=invoice_ids"`
	// invoice_status filters by the current state of invoices in their lifecycle
	// Multiple statuses can be specified to include invoices in any of the listed states
	InvoiceStatus []InvoiceStatus `queryParam:"style=form,explode=false,name=invoice_status"`
	// invoice_type filters by the nature of the invoice (SUBSCRIPTION, ONE_OFF, or CREDIT)
	// Use this to separate recurring charges from one-time fees or credit adjustments
	InvoiceType *InvoiceType      `queryParam:"style=form,explode=true,name=invoice_type"`
	Limit       *int64            `queryParam:"style=form,explode=true,name=limit"`
	Offset      *int64            `queryParam:"style=form,explode=true,name=offset"`
	Order       *GetInvoicesOrder `queryParam:"style=form,explode=true,name=order"`
	// payment_status filters by the payment state of invoices
	// Multiple statuses can be specified to include invoices with any of the listed payment states
	PaymentStatus []PaymentStatus `queryParam:"style=form,explode=false,name=payment_status"`
	// SkipLineItems if true, will not include line items in the response
	SkipLineItems *bool              `queryParam:"style=form,explode=true,name=skip_line_items"`
	StartTime     *string            `queryParam:"style=form,explode=true,name=start_time"`
	Status        *GetInvoicesStatus `queryParam:"style=form,explode=true,name=status"`
	// subscription_id filters invoices generated for a specific subscription
	// Only returns invoices that were created as part of the specified subscription's billing
	SubscriptionID *string `queryParam:"style=form,explode=true,name=subscription_id"`
}

func (g GetInvoicesRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetInvoicesRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (g *GetInvoicesRequest) GetAmountDueGt() *float64 {
	if g == nil {
		return nil
	}
	return g.AmountDueGt
}

func (g *GetInvoicesRequest) GetAmountRemainingGt() *float64 {
	if g == nil {
		return nil
	}
	return g.AmountRemainingGt
}

func (g *GetInvoicesRequest) GetCustomerID() *string {
	if g == nil {
		return nil
	}
	return g.CustomerID
}

func (g *GetInvoicesRequest) GetEndTime() *string {
	if g == nil {
		return nil
	}
	return g.EndTime
}

func (g *GetInvoicesRequest) GetExpand() *string {
	if g == nil {
		return nil
	}
	return g.Expand
}

func (g *GetInvoicesRequest) GetExternalCustomerID() *string {
	if g == nil {
		return nil
	}
	return g.ExternalCustomerID
}

func (g *GetInvoicesRequest) GetInvoiceIds() []string {
	if g == nil {
		return nil
	}
	return g.InvoiceIds
}

func (g *GetInvoicesRequest) GetInvoiceStatus() []InvoiceStatus {
	if g == nil {
		return nil
	}
	return g.InvoiceStatus
}

func (g *GetInvoicesRequest) GetInvoiceType() *InvoiceType {
	if g == nil {
		return nil
	}
	return g.InvoiceType
}

func (g *GetInvoicesRequest) GetLimit() *int64 {
	if g == nil {
		return nil
	}
	return g.Limit
}

func (g *GetInvoicesRequest) GetOffset() *int64 {
	if g == nil {
		return nil
	}
	return g.Offset
}

func (g *GetInvoicesRequest) GetOrder() *GetInvoicesOrder {
	if g == nil {
		return nil
	}
	return g.Order
}

func (g *GetInvoicesRequest) GetPaymentStatus() []PaymentStatus {
	if g == nil {
		return nil
	}
	return g.PaymentStatus
}

func (g *GetInvoicesRequest) GetSkipLineItems() *bool {
	if g == nil {
		return nil
	}
	return g.SkipLineItems
}

func (g *GetInvoicesRequest) GetStartTime() *string {
	if g == nil {
		return nil
	}
	return g.StartTime
}

func (g *GetInvoicesRequest) GetStatus() *GetInvoicesStatus {
	if g == nil {
		return nil
	}
	return g.Status
}

func (g *GetInvoicesRequest) GetSubscriptionID() *string {
	if g == nil {
		return nil
	}
	return g.SubscriptionID
}
